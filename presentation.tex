\documentclass{beamer}
\title{Clocks and Snapshots}
\author{Michael Whittaker}

\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{calc}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\carets}[1]{\left\langle #1 \right\rangle}

\newcommand{\picframe}[3]{
  % http://tex.stackexchange.com/a/3927
  { % all template changes are local to this group.

    \setbeamertemplate{navigation symbols}{}
    \begin{frame}[plain]
      \begin{tikzpicture}[remember picture,overlay]
        \node[at=(current page.center)] {
          \includegraphics[#2]{#1}
        };
      \end{tikzpicture}
      \vskip0pt plus 1filll
      \tiny #3
    \end{frame}
  }
}

\newcommand{\clocktower}{
  \picframe{clocktower}{height=\paperheight}{\url{http://bit.ly/1PCy5ye}}
}

\newcommand{\whattime}{
  \picframe{adventure-time}{height=0.5\paperheight}{http://bit.ly/1WnG32c}
}

\newcommand{\spacetime}{
  \picframe{clock}{height=\paperheight}{}
}

\newcommand{\naive}{
  \picframe{naive}{height=\paperheight}{}
}

\newcommand{\mutex}[1]{
  \picframe{mutex#1}{height=\paperheight}{}
}

\newcommand{\frozen}{
  \picframe{frozen}{height=\paperheight}{http://bit.ly/1LIDXXG}
}

\begin{document}
\begin{frame}
  \titlepage
\end{frame}

% We use time every day as a way to order events. For example, an event that
% occurred at 10:15 comes before an event at 10:20. However, we run into some
% difficulties when we try to apply these same notions of time to a distributed
% system.
\clocktower{}

\begin{frame}{Mathematical Preliminaries: Relations}
    A \emph{relation} $R$ on sets $A$ and $B$ is a subset of $A \times B$.
    Alternatively, a relation $R$ on a set $A$ is a subset of $A \times A$.
    \[
      R \subseteq A \times B, \qquad R \subseteq A \times A
    \]

    \pause

    For example, the following sets are relations on $A = \set{1, 2}$ and $B =
    \set{x, y, z}$.
      \begin{itemize}
        \item $\set{(1, x), (2, x)}$
        \item $\set{(1, x), (1, y), (2, z)}$
        \item $A \times B$
        \item $\set{}$
      \end{itemize}

    \pause

    We denote $(a, b) \in R$ as $a R b$. For example $1 = 1$ denotes $(1, 1)
    \in =$, and $1 \leq 42$ denotes $(1, 42) \in \leq$.
\end{frame}

\begin{frame}{Mathematical Preliminaries: Partial Orderings}
  An \emph{irreflexive partial ordering} $<$ on a set $A$ is a relation on $A$
  that satisfies three properties:
  \begin{enumerate}
    \item \textbf{irreflexivity} $a \not< a$.
    \item \textbf{antisymmetry} If $a < b$ then $b \not< a$.
    \item \textbf{transitivity} If $a < b$ and $b < c$, then $a < c$.
  \end{enumerate}
\end{frame}

\begin{frame}{Mathematical Preliminaries: Partial Orderings}
  For example, the strict subset relation $\subset$ is an irreflexive partial
  order on the powerset $2^A$ of some a set $A$.
  \begin{enumerate}
    \item \textbf{irreflexivity} $\set{1, 2, 3} \not\subset \set{1, 2, 3}$.
    \item \textbf{antisymmetry} $\set{1, 2} \subset \set{1, 2, 3}$, so $\set{1,
      2, 3} \not\subset \set{1, 2}$.
    \item \textbf{transitivity} $\set{1} \subset \set{1, 2}$ and $\set{1, 2}
      \subset \set{1, 2, 3}$, so $\set{1} \subset \set{1, 2, 3}$.
  \end{enumerate}

  \pause

  Note it's not always true that $a < b$ or $b < a$. For example, $\set{1, 2}
  \not\subset \set{2, 3}$ and $\set{2, 3} \not\subset \set{1, 2}$.
\end{frame}

\begin{frame}{Mathematical Preliminaries: Total Orderings}
  A \emph{irreflexive total ordering} $<$ on a set $A$ is an irreflexive
  partial ordering on $A$ that satisfies the additional property:
  \begin{enumerate}
    \item \textbf{totality} If $a \neq b$ then $a < b$ or $b < a$.
  \end{enumerate}
\end{frame}

% With the mathematical preliminaries out of the way, we can now ask ourselves
% in the context of a distributed system, what does it mean to ask "what time
% is it"? Alternatively, we can ask ourselves what it means to ask whether one
% event happened before another. Since clocks skew, we can't use physical
% clocks reliably. Instead, we'll develop an irreflexive partial order of
% events in a distributed system without using clocks.
\whattime{}

% Before we develop the ordering, let's semi-formalize our system. Our system
% is composed of a set of processes each of which execute a totally ordered set
% of events. An event can be one of three types:
%
%   (1) A local event (e.g. a2)
%   (2) A send event (e.g. a0)
%   (2) A receive event (e.g. b2)
%
% We'll depict systems as graphs where time flows from bottom to top, events
% are drawn as circles, and colored lines are drawn between pairs of send and
% receive events.
\spacetime{}

\begin{frame}{Constructing a Partial Order}
  We want to define an irreflexive partial ordering $\to$ on the set of events
  in a distributed system. Define $\to$ to be the smallest relation satisfying
  the following rules:
  \begin{enumerate}
    \item If $a_i$ comes before $a_j$ is a process $a$, then $a_i \to a_j$.
    \item If $a$ is the sending of a message and $b$ is the receipt of the
      message, then $a \to b$.
    \item If $a \to b$ and $b \to c$, then $a \to c$.
  \end{enumerate}
\end{frame}

% We can interpret a -> b to mean that there is a path from a to b in the
% system diagram. Alternatively, we can interpret a -> b to mean that its
% possible for a to causally affect b.
\spacetime{}

\begin{frame}{Specifying Logical Clocks}
  Define a clock $C$ as a function from events to natural numbers where we
  denote $C\carets{a}$ as the number assigned to $a$ by $C$.
  % This is similar to the notion of a physical clock as a function from events
  % to real numbers.
  A clock is correct if it satisfies the \textbf{Clock Condition}:
  \[
    \forall a, b.\> a \to b \implies C\carets{a} < C\carets{b}
  \]

  Note that the converse does not need to be satisfied!
\end{frame}

\begin{frame}{Implementing Logical Clocks}
  Each process $i$ maintains a register $C_i$. For an event $a$ that occurs on
  process $i$, let $C\carets{a}$ be $C_i$ at the time of $a$. Each process
  updates $C_i$ as follows:
  \begin{enumerate}
    \item $C_i$ is incremented between any two events.
    \item If $a$ is the sending of a message $m$ from process $i$ to process
      $j$, then $m$ includes $C\carets{a}$ and $j$ updates $C_j$ to be larger
      than the old value of $C_j$ and $C\carets{a}$.
  \end{enumerate}
\end{frame}

% Walk through an example of how the algorithm executes.
\spacetime{}

% Now we have an irreflexive total ordering on events using logical clocks. We
% can extend this to a total ordering of events.
\begin{frame}{Constructing a Total Ordering}
  Consider an arbitrary total ordering $<$ on processes. Let's define a
  $\Rightarrow$ be a total ordering of events where $a_i \Rightarrow b_j$ if and
  only if
  \begin{enumerate}
    \item $C\carets{a_i} < C\carets{b_j}$, or
    \item $C\carets{a_i} = C\carets{b_j}$ and $a < b$.
  \end{enumerate}
\end{frame}

% Show example of total ordering.
\spacetime{}

\begin{frame}{Distributed Mutual Exclusion}
  A set of processes share a single resource that should be held by at most one
  processor at a time. We want an algorithm to enforce mutual exclusion such
  that:
  \begin{enumerate}
    \item \textbf{safety:} At most one process holds the resource.
    \item \textbf{ordering:} Resource requests should be granted according to
      the happens before relation $\to$.
    \item \textbf{progress:} If the resource is held for a finite amount of
      time, all requests will eventually be granted.
  \end{enumerate}
  Assume processes form a clique and never fail and that the network guarantees
  reliable FIFO communication. Also assume one process has the resource
  initially.
\end{frame}

% Show that a naive solution is incorrect. Here, b0 -> c1, but a0 -> a1. This
% violates property 2 from above.
\naive{}

\begin{frame}{Lamport's Mutual Exclusion Algorithm}
  Each process maintains a \emph{request queue} which initially contains $0:p$.
  Each process follows five rules.
  \begin{enumerate}
    \item To request the resource, process $a$ sends $i:a$ to all processes.
    \item When a process receives $i:a$, it inserts it in the queue and acknowledges.
    \item To release the resource, sends a release message to all processes.
    \item When a process receives a release message from $a$ it removes all
      $i:a$ from its queue.
    \item Process $a$ is granted the resource when the head of the queue is
      $[i:a]$ and it has seen messages from all processes later than $i$.
  \end{enumerate}
\end{frame}

% Shortly describe why this algorithm guarantees correctness.
\foreach \i in {1, 2, 3, 4} {
  \mutex{\i}
}

\frozen{}

\tikzstyle{vert}=[circle, minimum width=1cm, draw, thick]

% Our system is composed of a finite set of processes and channels represented
% as vertices and edges in a directed graph. Channels are assumed to
%
%   (a) have infinite buffers, and
%   (b) be error-free, and
%   (c) deliver messages FIFO.
%
% Channel delay is arbitrary but finite.
\begin{frame}
  \begin{center}
    \begin{tikzpicture}
      \node[vert, fill=red!20]   (p) at (0, 0)  {$p$};
      \node[vert, fill=blue!20]  (q) at (0:3)   {$q$};
      \node[vert, fill=green!20] (r) at (300:3) {$r$};
      \draw[thick, ->] (p.35)  -- node[above]{$C_1$} (q.145);
      \draw[thick, ->] (p.325) -- node[below]{$C_2$} (q.215);
      \draw[thick, ->] (q)     -- node[right]{$C_3$} (r);
        \draw[thick, ->] (r)   -- node[left ]{$C_4$} (p);
    \end{tikzpicture}
  \end{center}
\end{frame}

\begin{frame}{Distributed System Model}
  A \emph{process} $p$ is a set of states $S$, an initial state $s$, and a set
  of events $E$.
  \[
    p \triangleq (S, s, E)
  \]

  \pause

  An \emph{event} $e \in E$ is defined by a process $p$, the state $s$ and $s'$
  of $p$ before and after $e$, the channel $(c | \bot)$ modified by $e$, and
  the message $(M | \bot)$ sent or received on $c$.
  \[
    e \triangleq (p, s, s', (M | \bot), (c | \bot))
  \]

  \pause

  A \emph{global state} is a set of process and channel states. The
  \emph{initial global state} has all processes in their initial states and all
  channels empty. A \emph{computation of the system} is a sequence of events.
  % Note that there are the intuitive restrictions on computations. Not all
  % sequences of events form a computation.
\end{frame}

\tikzstyle{vert}=[circle, inner sep=0cm, minimum width=0.5cm, draw, thick]
\tikzstyle{p}=[vert, fill=red!20]
\tikzstyle{q}=[vert, fill=blue!20]

\newcommand{\barbell}[6]{
  \node[p]                     (p#1) at #2 {#3};
  \node[q, right=0.5cm of p#1] (q#1)       {#4};
  \draw[->, thick] (p#1.35)  -- node[above]{#5} (q#1.145);
  \draw[<-, thick] (p#1.325) -- node[below]{#6} (q#1.215);

  \node (c#1) at ($(p#1)!0.5!(q#1)$) {};

  \node[above=0.35cm of c#1] (n#1) {};
  \node[right=0.25cm of q#1] (e#1) {};
  \node[below=0.35cm of c#1] (s#1) {};
  \node[left =0.25cm of p#1] (w#1) {};

  \node[above=0.35cm of e#1] (ne#1) {};
  \node[below=0.35cm of e#1] (se#1) {};
  \node[below=0.35cm of w#1] (sw#1) {};
  \node[above=0.35cm of w#1] (nw#1) {};
}

\newcommand{\blt}{\ensuremath{\bullet}}
\newcommand{\bbt}{\ensuremath{\bullet \bullet}}

\newcommand{\onetoken}{
  \barbell{1}{(0,  0)}{\blt}{    }{    }{    };
  \barbell{2}{(5,  0)}{    }{    }{\blt}{    };
  \barbell{3}{(5, -3)}{    }{\blt}{    }{    };
  \barbell{4}{(0, -3)}{    }{    }{    }{\blt};
  \draw[ultra thick, ->, black] (e1) -- (w2);
  \draw[ultra thick, ->, red  ] (s2) -- (n3);
  \draw[ultra thick, ->, green] (w3) -- (e4);
  \draw[ultra thick, ->, blue ] (n4) -- (s1);
}

% This is a concise way to describe the set of all global system states and the
% set of all computations. Here, each process and each channel has two states.
% Each vertex in this graph of graphs is a global system state. Every finite
% length walk starting from the initial state is a computation. This example is
% a single-token system.
\begin{frame}
  \begin{center}
    \begin{tikzpicture}
      \onetoken
    \end{tikzpicture}
  \end{center}
\end{frame}

\newcommand{\twotoken}{
    \barbell{01}{(+0, +0)}{\blt}{\blt}{    }{    };
    \barbell{02}{(+1, +1)}{\blt}{    }{    }{\blt};
    \barbell{03}{(+1, -1)}{    }{\blt}{\blt}{    };
    \barbell{04}{(+2, +2)}{\bbt}{    }{    }{    };
    \barbell{05}{(+2, +0)}{    }{    }{\blt}{\blt};
    \barbell{06}{(+2, -2)}{    }{\bbt}{    }{    };
    \barbell{07}{(+3, +2)}{\blt}{    }{\blt}{    };
    \barbell{08}{(+3, -2)}{    }{\blt}{    }{\blt};
    \barbell{09}{(+4, +1)}{    }{    }{    }{\bbt};
    \barbell{10}{(+4, -1)}{    }{    }{\bbt}{    };
    \draw[ultra thick, ->, black] (e01) -- (w02);
    \draw[ultra thick, ->, blue ] (e01) -- (w03);
    \draw[ultra thick, ->, green] (e02) -- (w04);
    \draw[ultra thick, ->, blue ] (e02) -- (w05);
    \draw[ultra thick, ->, black] (e03) -- (w05);
    \draw[ultra thick, ->, red  ] (e03) -- (w06);
    \draw[ultra thick, ->, blue ] (e04) -- (w07);
    \draw[ultra thick, ->, green] (e05) -- (w07);
    \draw[ultra thick, ->, red  ] (e05) -- (w08);
    \draw[ultra thick, ->, black] (e06) -- (w08);
    \draw[ultra thick, ->, blue ] (e07) -- (w10);
    \draw[ultra thick, ->, black] (e08) -- (w09);
    \draw[ultra thick, ->, green] (w09) -- (e02);
    \draw[ultra thick, ->, red  ] (w10) -- (e03);
}

% Here is a double-token system. Unlike the single-token system, this system is
% non-deterministic meaning some states have multiple outgoing edges.
\begin{frame}
  \begin{center}
    \scalebox{0.7}{
      \begin{tikzpicture}[xscale=3, yscale=1.5]
        \twotoken{}
      \end{tikzpicture}
    }
  \end{center}
\end{frame}

% Notice that if we take a snapshot of p in the initial state and a snapshot of
% the upper channel in the next state, our snapshot includes two tokens.
% Similarly, if we take a snapshot of the channel in the first state and a
% snapshot of p in the second state, we have no tokens.
%
% This shows that there is a certain order in which we have to take snapshots.
% We cannot record the state of a sender's channel after the sender's state has
% been recorded and after it has sent a message on its outgoing channel.
\begin{frame}
  \begin{center}
    \begin{tikzpicture}
      \onetoken
    \end{tikzpicture}
  \end{center}
\end{frame}

\begin{frame}{Snapshot Algorithm}
  \textbf{Marker-Sending Rule}. For each process $p$ and for each channel $c$
  away from $p$, $p$ records its state and immediately sends a token along $c$.

  \textbf{Marker-Receiving Rule}. For each process $q$ and for each channel $c$
  into $q$, when $q$ receives a token from $c$,
  \begin{itemize}
    \item If $q$ has not yet recorded its state, it records its state and
      records the state of $c$ as the empty sequence.
    \item If $q$ has recorded its state, it records the state of $c$ as the
      sequence of messages since it recorded its state.
  \end{itemize}
\end{frame}

\tikzstyle{v}=[circle, minimum width=1cm]
\tikzstyle{snapped}=[thick, draw, fill=red!50]
\tikzstyle{transient}=[thick, draw, dashed, fill=red!10]
\tikzstyle{arrow}=[ultra thick, ->]
\tikzstyle{darrow}=[ultra thick, ->, dashed]
\tikzstyle{msg}=[above, sloped]

\newcommand{\av}[1]{\node[v, #1] (a) at (0,  0) {$a$};}
\newcommand{\bv}[1]{\node[v, #1] (b) at (4,  2) {$b$};}
\newcommand{\cv}[1]{\node[v, #1] (c) at (4, -2) {$c$};}
\newcommand{\dv}[1]{\node[v, #1] (d) at (8,  0) {$d$};}
\newcommand{\nodes}[4]{
  \av{#1}
  \bv{#2}
  \cv{#3}
  \dv{#4}
}

\newcommand{\ab}[2]{\draw[#1] (a) to node[msg]{#2} (b);}
\newcommand{\ac}[2]{\draw[#1] (a) to node[msg]{#2} (c);}
\newcommand{\bc}[2]{\draw[#1] (b) to node[msg]{#2} (c);}
\newcommand{\bd}[2]{\draw[#1] (b) to node[msg]{#2} (d);}
\newcommand{\cd}[2]{\draw[#1] (c) to node[msg]{#2} (d);}

\newcommand{\tok}{\textcolor{black}{\bullet}\>}
\newcommand{\pre}{\textcolor{red!20}{\bullet}\>}
\newcommand{\post}{\textcolor{red!50}{\bullet}\>}

\begin{frame}
  \begin{center}
    \begin{tikzpicture}
      \nodes{transient}{transient}{transient}{transient}
      \ab{darrow}{$\pre \pre \pre$}
      \ac{darrow}{$\pre$}
      \bc{darrow}{$\pre \pre$}
      \bd{darrow}{$ $}
      \cd{darrow}{$\pre$}
    \end{tikzpicture}
  \end{center}
\end{frame}

\begin{frame}
  \begin{center}
    \begin{tikzpicture}
      \nodes{snapped}{transient}{transient}{transient}
      \ab{darrow}{$\tok \pre \pre$}
      \ac{darrow}{$\tok$}
      \bc{darrow}{$\pre$}
      \bd{darrow}{$\pre$}
      \cd{darrow}{$\pre \pre$}
    \end{tikzpicture}
  \end{center}
\end{frame}

\begin{frame}
  \begin{center}
    \begin{tikzpicture}
      \nodes{snapped}{transient}{snapped}{transient}
      \ab{darrow}{$\post \tok \pre$}
      \ac{arrow}{$\post$}
      \bc{darrow}{$\pre \pre$}
      \bd{darrow}{$ $}
      \cd{darrow}{$\tok \pre \pre$}
    \end{tikzpicture}
  \end{center}
\end{frame}

\begin{frame}
  \begin{center}
    \begin{tikzpicture}
      \nodes{snapped}{transient}{snapped}{transient}
      \ab{darrow}{$\post \tok$}
      \ac{arrow}{$\post \post$}
      \bc{darrow}{$\pre$}
      \bd{darrow}{$\pre$}
      \cd{darrow}{$\post \tok \pre$}
    \end{tikzpicture}
  \end{center}
\end{frame}

\begin{frame}
  \begin{center}
    \begin{tikzpicture}
      \nodes{snapped}{snapped}{snapped}{transient}
      \ab{arrow}{$\post \post$}
      \ac{arrow}{$\post \post$}
      \bc{darrow}{$\tok \pre$}
      \bd{darrow}{$\tok \pre$}
      \cd{darrow}{$\post \post \tok$}
    \end{tikzpicture}
  \end{center}
\end{frame}

\begin{frame}
  \begin{center}
    \begin{tikzpicture}
      \nodes{snapped}{snapped}{snapped}{snapped}
      \ab{arrow}{$\post \post \post$}
      \ac{arrow}{$\post$}
      \bc{darrow}{$\post \tok$}
      \bd{darrow}{$\tok$}
      \cd{arrow}{$\post \post \post$}
    \end{tikzpicture}
  \end{center}
\end{frame}

\begin{frame}
  \begin{center}
    \begin{tikzpicture}
      \nodes{snapped}{snapped}{snapped}{snapped}
      \ab{arrow}{$\post \post \post \post$}
      \ac{arrow}{$\ $}
      \bc{arrow}{$\post \post$}
      \bd{arrow}{$\post$}
      \cd{arrow}{$\post \post$}
    \end{tikzpicture}
  \end{center}
\end{frame}

% Let's walk through the example presented in the paper. The red process
% records its state in the initial state. Then, the computation steps forward
% three events at which point, both channels and the blue state snapshot their
% states. The resulting snapshot is the one in a dashed box.
%
% If our snapshot algorithm produced a state that wasn't in our computation,
% what good is the snapshot? Well, there's a couple nice properties of our
% snapshot. First, notice that the snapshot is reachable from the initial
% state, and the final state is reachable from our snapshot.
\begin{frame}
  \begin{center}
    \scalebox{0.7}{
      \begin{tikzpicture}[xscale=3, yscale=1.5]
        \twotoken{}
        \pause
        \draw (sw01) rectangle (ne01);
        \pause
        \draw (sw03) rectangle (ne03);
        \pause
        \draw (sw05) rectangle (ne05);
        \pause
        \draw (sw07) rectangle (ne07);
        \pause
        \draw[dashed] (sw02) rectangle (ne02);
      \end{tikzpicture}
    }
  \end{center}
\end{frame}

\newcommand{\blackto}{\tikz{\draw[->, black, ultra thick] (0, 0) -- (0.5, 0);}}
\newcommand{\blueto}{\tikz{\draw[->, blue, ultra thick] (0, 0) -- (0.5, 0);}}
\newcommand{\greento}{\tikz{\draw[->, green, ultra thick] (0, 0) -- (0.5, 0);}}

% Moreover, there is a permutation of the computation that begins in the
% initial state, reaches the snapshot state, and terminates in the final state.
% In this example, our computation is blue, black, green. We can permute this
% to black, blue, green.
\begin{frame}
  \begin{center}
    \scalebox{0.7}{
      \begin{tikzpicture}[xscale=3, yscale=1.5]
        \twotoken{}
        \draw (sw01) rectangle (ne01);
        \draw (sw03) rectangle (ne03);
        \draw (sw05) rectangle (ne05);
        \draw (sw07) rectangle (ne07);
        \draw[dashed] (sw02) rectangle (ne02);
      \end{tikzpicture}
    }
  \end{center}
  \begin{gather*}
    \blueto \quad \blackto \quad \greento \\
    \blackto \quad \blueto \quad \greento
  \end{gather*}
\end{frame}

\begin{frame}{Snapshot Properties}
  Consider a computation $seq = S_0 e_0 S_1 e_1 \ldots S_\iota e_\iota \ldots
  S_\phi e_\phi \ldots S_n e_n$ where we initiate the snapshot algorithm in
  $S_\iota$ and the algorithm termiantes in $S_\phi$. Denote the snapshot state
  $S^*$.  We've seen that $S^*$ might not be equal to any $S_j$ for $\iota \leq
  j \leq \phi$. Howover, we can show that:
  \begin{enumerate}
    \item $S^*$ is reachable from $S_\iota$, and
    \item $S_\phi$ is reachable from $S^*$.
  \end{enumerate}
\end{frame}

\begin{frame}{Snapshot Properties}
  Even stronger, we can show that there exists a computation $seq'$ such that:
  \begin{enumerate}
    \item For all $i < \iota$, $i \geq \phi$, $e_i' = e_i$, and
    \item $(e_j', \iota \leq j < \phi)$ is a permutation of $(e_j, \iota \leq i
      < \phi)$, and
    \item there exists some $\iota \leq k \leq \phi$ such that $S^* = S_k'$.
  \end{enumerate}
\end{frame}

\begin{frame}{Stable Properties}
  Conceptually, a stable property of a distributed system $D$ is a property
  that is monotonically true. That is, once it becomes true, it remains true.

  \pause

  For example, the following are stable properties:
  \begin{itemize}
    \item Our one-token system has one token
    \item Our two-token system has two tokens
    \item Computation has terminated
    \item Computation is deadlocked
  \end{itemize}

  \pause

  Formally, a stable property $y$ is a predicate on the global states $S$ of a
  distributed system $D$. with the property that if $y(S)$ is true then $y(S')$
  is true for all states $S'$ reachable from $S$.
\end{frame}

% It's clear that the two-token system having two-tokens is a stable property
% because all states have two tokens!
\begin{frame}
  \begin{center}
    \scalebox{0.7}{
      \begin{tikzpicture}[xscale=3, yscale=1.5]
        \twotoken{}
      \end{tikzpicture}
    }
  \end{center}
\end{frame}

\begin{frame}{Stable Property Detection}
  We want to construct an algorithm that takes as input a distributed system
  $D$ and a stable property $y$, and outputs a boolean $b$ such that
  \[
    y(S_\iota) \implies b, \qquad b \implies y(S_\phi)
  \]
  Intuitively, if $b$ is true, then $y(S_\phi)$ is true. If $b$ is false, then
  $y(S_\iota)$ is false.

  \pause

  The algorithm itself is trivial:
  \begin{enumerate}
    \item Record a global state $S^*$
    \item Output $y(S^*)$
  \end{enumerate}
\end{frame}

% Looking at a system diagram, it should be clear why this is the case. If
% y(S*) is true, then by the definition of a stable property, y(S_phi) is true
% because S_phi is reachable from S*. Alternatively, if S* is not true, by the
% definition of a stable property, S_iota must not be true since S* is
% reachable from S_iota.
\begin{frame}
  \begin{center}
    \scalebox{0.7}{
      \begin{tikzpicture}[xscale=3, yscale=1.5]
        \twotoken{}
      \end{tikzpicture}
    }
  \end{center}
\end{frame}

\end{document}
