\documentclass{beamer}
\title{Clocks and Snapshots}
\author{Michael Whittaker}

\usepackage{tikz}
\usetikzlibrary{positioning}
\usetikzlibrary{calc}
\newcommand{\set}[1]{\left\{#1\right\}}
\newcommand{\carets}[1]{\left\langle #1 \right\rangle}

\newcommand{\picframe}[3]{
  % http://tex.stackexchange.com/a/3927
  { % all template changes are local to this group.

    \setbeamertemplate{navigation symbols}{}
    \begin{frame}[plain]
      \begin{tikzpicture}[remember picture,overlay]
        \node[at=(current page.center)] {
          \includegraphics[#2]{#1}
        };
      \end{tikzpicture}
      \vskip0pt plus 1filll
      \tiny #3
    \end{frame}
  }
}

\newcommand{\clocktower}{
  \picframe{clocktower}{height=\paperheight}{\url{http://bit.ly/1PCy5ye}}
}

\newcommand{\whattime}{
  \picframe{adventure-time}{height=0.5\paperheight}{http://bit.ly/1WnG32c}
}

\newcommand{\spacetime}{
  \picframe{clock}{height=\paperheight}{}
}

\newcommand{\naive}{
  \picframe{naive}{height=\paperheight}{}
}

\newcommand{\mutex}[1]{
  \picframe{mutex#1}{height=\paperheight}{}
}

\begin{document}
\begin{frame}
  \titlepage
\end{frame}

% We use time every day as a way to order events. For example, an event that
% occurred at 10:15 comes before an event at 10:20. However, we run into some
% difficulties when we try to apply these same notions of time to a distributed
% system.
\clocktower{}

\begin{frame}{Mathematical Preliminaries: Relations}
    A \emph{relation} $R$ on sets $A$ and $B$ is a subset of $A \times B$.
    Alternatively, a relation $R$ on a set $A$ is a subset of $A \times A$.
    \[
      R \subseteq A \times B, \qquad R \subseteq A \times A
    \]

    \pause

    For example, the following sets are relations on $A = \set{1, 2}$ and $B =
    \set{x, y, z}$.
      \begin{itemize}
        \item $\set{(1, x), (2, x)}$
        \item $\set{(1, x), (1, y), (2, z)}$
        \item $A \times B$
        \item $\set{}$
      \end{itemize}

    \pause

    We denote $(a, b) \in R$ as $a R b$. For example $1 = 1$ denotes $(1, 1)
    \in =$, and $1 \leq 42$ denotes $(1, 42) \in \leq$.
\end{frame}

\begin{frame}{Mathematical Preliminaries: Partial Orderings}
  An \emph{irreflexive partial ordering} $<$ on a set $A$ is a relation on $A$
  that satisfies three properties:
  \begin{enumerate}
    \item \textbf{irreflexivity} $a \not< a$.
    \item \textbf{antisymmetry} If $a < b$ then $b \not< a$.
    \item \textbf{transitivity} If $a < b$ and $b < c$, then $a < c$.
  \end{enumerate}
\end{frame}

\begin{frame}{Mathematical Preliminaries: Partial Orderings}
  For example, the strict subset relation $\subset$ is an irreflexive partial
  order on the powerset $2^A$ of some a set $A$.
  \begin{enumerate}
    \item \textbf{irreflexivity} $\set{1, 2, 3} \not\subset \set{1, 2, 3}$.
    \item \textbf{antisymmetry} $\set{1, 2} \subset \set{1, 2, 3}$, so $\set{1,
      2, 3} \not\subset \set{1, 2}$.
    \item \textbf{transitivity} $\set{1} \subset \set{1, 2}$ and $\set{1, 2}
      \subset \set{1, 2, 3}$, so $\set{1} \subset \set{1, 2, 3}$.
  \end{enumerate}

  \pause

  Note it's not always true that $a < b$ or $b < a$. For example, $\set{1, 2}
  \not\subset \set{2, 3}$ and $\set{2, 3} \not\subset \set{1, 2}$.
\end{frame}

\begin{frame}{Mathematical Preliminaries: Total Orderings}
  A \emph{irreflexive total ordering} $<$ on a set $A$ is an irreflexive
  partial ordering on $A$ that satisfies the additional property:
  \begin{enumerate}
    \item \textbf{totality} If $a \neq b$ then $a < b$ or $b < a$.
  \end{enumerate}
\end{frame}

% With the mathematical preliminaries out of the way, we can now ask ourselves
% in the context of a distributed system, what does it mean to ask "what time
% is it"? Alternatively, we can ask ourselves what it means to ask whether one
% event happened before another. Since clocks skew, we can't use physical
% clocks reliably. Instead, we'll develop an irreflexive partial order of
% events in a distributed system without using clocks.
\whattime{}

% Before we develop the ordering, let's semi-formalize our system. Our system
% is composed of a set of processes each of which execute a totally ordered set
% of events. An event can be one of three types:
%
%   (1) A local event (e.g. a2)
%   (2) A send event (e.g. a0)
%   (2) A receive event (e.g. b2)
%
% We'll depict systems as graphs where time flows from bottom to top, events
% are drawn as circles, and colored lines are drawn between pairs of send and
% receive events.
\spacetime{}

\begin{frame}{Constructing a Partial Order}
  We want to define an irreflexive partial ordering $\to$ on the set of events
  in a distributed system. Define $\to$ to be the smallest relation satisfying
  the following rules:
  \begin{enumerate}
    \item If $a_i$ comes before $a_j$ is a process $a$, then $a_i \to a_j$.
    \item If $a$ is the sending of a message and $b$ is the receipt of the
      message, then $a \to b$.
    \item If $a \to b$ and $b \to c$, then $a \to c$.
  \end{enumerate}
\end{frame}

% We can interpret a -> b to mean that there is a path from a to b in the
% system diagram. Alternatively, we can interpret a -> b to mean that its
% possible for a to causally affect b.
\spacetime{}

\begin{frame}{Specifying Logical Clocks}
  Define a clock $C$ as a function from events to natural numbers where we
  denote $C\carets{a}$ as the number assigned to $a$ by $C$.
  % This is similar to the notion of a physical clock as a function from events
  % to real numbers.
  A clock is correct if it satisfies the \textbf{Clock Condition}:
  \[
    \forall a, b.\> a \to b \implies C\carets{a} < C\carets{b}
  \]

  Note that the converse does not need to be satisfied!
\end{frame}

\begin{frame}{Implementing Logical Clocks}
  Each process $i$ maintains a register $C_i$. For an event $a$ that occurs on
  process $i$, let $C\carets{a}$ be $C_i$ at the time of $a$. Each process
  updates $C_i$ as follows:
  \begin{enumerate}
    \item $C_i$ is incremented between any two events.
    \item If $a$ is the sending of a message $m$ from process $i$ to process
      $j$, then $m$ includes $C\carets{a}$ and $j$ updates $C_j$ to be larger
      than the old value of $C_j$ and $C\carets{a}$.
  \end{enumerate}
\end{frame}

% Walk through an example of how the algorithm executes.
\spacetime{}

% Now we have an irreflexive total ordering on events using logical clocks. We
% can extend this to a total ordering of events.
\begin{frame}{Constructing a Total Ordering}
  Consider an arbitrary total ordering $<$ on processes. Let's define a
  $\Rightarrow$ be a total ordering of events where $a_i \Rightarrow b_j$ if and
  only if
  \begin{enumerate}
    \item $C\carets{a_i} < C\carets{b_j}$, or
    \item $C\carets{a_i} = C\carets{b_j}$ and $a < b$.
  \end{enumerate}
\end{frame}

% Show example of total ordering.
\spacetime{}

\begin{frame}{Distributed Mutual Exclusion}
  A set of processes share a single resource that should be held by at most one
  processor at a time. We want an algorithm to enforce mutual exclusion such
  that:
  \begin{enumerate}
    \item \textbf{safety:} At most one process holds the resource.
    \item \textbf{ordering:} Resource requests should be granted according to
      the happens before relation $\to$.
    \item \textbf{progress:} If the resource is held for a finite amount of
      time, all requests will eventually be granted.
  \end{enumerate}
  Assume processes form a clique and never fail and that the network guarantees
  reliable FIFO communication. Also assume one process has the resource
  initially.
\end{frame}

% Show that a naive solution is incorrect. Here, b0 -> c1, but a0 -> a1. This
% violates property 2 from above.
\naive{}

\begin{frame}{Lamport's Mutual Exclusion Algorithm}
  Each process maintains a \emph{request queue} which initially contains $0:p$.
  Each process follows five rules.
  \begin{enumerate}
    \item To request the resource, process $a$ sends $i:a$ to all processes.
    \item When a process receives $i:a$, it inserts it in the queue and acknowledges.
    \item To release the resource, sends a release message to all processes.
    \item When a process receives a release message from $a$ it removes all
      $i:a$ from its queue.
    \item Process $a$ is granted the resource when the head of the queue is
      $[i:a]$ and it has seen messages from all processes later than $i$.
  \end{enumerate}
\end{frame}

% Shortly describe why this algorithm guarantees correctness.
\foreach \i in {1, 2, 3, 4} {
  \mutex{\i}
}

\tikzstyle{vert}=[circle, inner sep=0cm, minimum width=0.5cm, draw, thick]
\tikzstyle{p}=[vert, fill=red!20]
\tikzstyle{q}=[vert, fill=blue!20]

\newcommand{\barbell}[6]{
  \node[p]                     (p#1) at #2 {#3};
  \node[q, right=0.5cm of p#1] (q#1)       {#4};
  \draw[->, thick] (p#1.45)  -- node[above]{#5} (q#1.135);
  \draw[<-, thick] (p#1.315) -- node[below]{#6} (q#1.225);
  \node (c#1) at ($(p#1)!0.5!(q#1)$) {};
  \node[above=0.35cm of c#1] (n#1) {};
  \node[right=0.25cm of q#1] (e#1) {};
  \node[below=0.35cm of c#1] (s#1) {};
  \node[left =0.25cm of p#1] (w#1) {};
}

\newcommand{\blt}{\ensuremath{\bullet}}
\newcommand{\bbt}{\ensuremath{\bullet \bullet}}

\begin{frame}
  \begin{center}
    \begin{tikzpicture}
      \barbell{1}{(0,  0)}{\blt}{    }{    }{    };
      \barbell{2}{(5,  0)}{    }{    }{\blt}{    };
      \barbell{3}{(5, -3)}{    }{\blt}{    }{    };
      \barbell{4}{(0, -3)}{    }{    }{    }{\blt};
      \draw[ultra thick, ->] (e1) -- (w2);
      \draw[ultra thick, ->] (s2) -- (n3);
      \draw[ultra thick, ->] (w3) -- (e4);
      \draw[ultra thick, ->] (n4) -- (s1);
    \end{tikzpicture}
  \end{center}
\end{frame}

\begin{frame}
  \begin{center}
    \scalebox{0.7}{
    \begin{tikzpicture}[xscale=3, yscale=1.5]
      \barbell{01}{(+0, +0)}{\blt}{\blt}{    }{    };
      \barbell{02}{(+1, +1)}{\blt}{    }{    }{\blt};
      \barbell{03}{(+1, -1)}{    }{\blt}{\blt}{    };
      \barbell{04}{(+2, +2)}{\bbt}{    }{    }{    };
      \barbell{05}{(+2, +0)}{    }{    }{\blt}{\blt};
      \barbell{06}{(+2, -2)}{    }{\bbt}{    }{    };
      \barbell{07}{(+3, +2)}{\blt}{    }{\blt}{    };
      \barbell{08}{(+3, -2)}{    }{\blt}{    }{\blt};
      \barbell{09}{(+4, +1)}{    }{    }{    }{\bbt};
      \barbell{10}{(+4, -1)}{    }{    }{\bbt}{    };
      \draw[ultra thick, ->] (e01) -- (w02);
      \draw[ultra thick, ->] (e01) -- (w03);
      \draw[ultra thick, ->] (e02) -- (w04);
      \draw[ultra thick, ->] (e02) -- (w05);
      \draw[ultra thick, ->] (e03) -- (w05);
      \draw[ultra thick, ->] (e03) -- (w06);
      \draw[ultra thick, ->] (e04) -- (w07);
      \draw[ultra thick, ->] (e05) -- (w07);
      \draw[ultra thick, ->] (e05) -- (w08);
      \draw[ultra thick, ->] (e06) -- (w08);
      \draw[ultra thick, ->] (e07) -- (w10);
      \draw[ultra thick, ->] (e08) -- (w09);
      \draw[ultra thick, ->] (w09) -- (e02);
      \draw[ultra thick, ->] (w10) -- (e03);
    \end{tikzpicture}
    }
  \end{center}
\end{frame}

\tikzstyle{v}=[circle, minimum width=1cm]
\tikzstyle{snapped}=[thick, draw, fill=red!50]
\tikzstyle{transient}=[thick, draw, dashed, fill=red!10]
\tikzstyle{arrow}=[ultra thick, ->]
\tikzstyle{darrow}=[ultra thick, ->, dashed]
\tikzstyle{msg}=[above, sloped]

\newcommand{\av}[1]{\node[v, #1] (a) at (0,  0) {$a$};}
\newcommand{\bv}[1]{\node[v, #1] (b) at (4,  2) {$b$};}
\newcommand{\cv}[1]{\node[v, #1] (c) at (4, -2) {$c$};}
\newcommand{\dv}[1]{\node[v, #1] (d) at (8,  0) {$d$};}
\newcommand{\nodes}[4]{
  \av{#1}
  \bv{#2}
  \cv{#3}
  \dv{#4}
}

\newcommand{\ab}[2]{\draw[#1] (a) to node[msg]{#2} (b);}
\newcommand{\ac}[2]{\draw[#1] (a) to node[msg]{#2} (c);}
\newcommand{\bc}[2]{\draw[#1] (b) to node[msg]{#2} (c);}
\newcommand{\bd}[2]{\draw[#1] (b) to node[msg]{#2} (d);}
\newcommand{\cd}[2]{\draw[#1] (c) to node[msg]{#2} (d);}

\newcommand{\tok}{\textcolor{black}{\bullet}\>}
\newcommand{\pre}{\textcolor{red!20}{\bullet}\>}
\newcommand{\post}{\textcolor{red!50}{\bullet}\>}

\begin{frame}
  \begin{center}
    \begin{tikzpicture}
      \nodes{transient}{transient}{transient}{transient}
      \ab{darrow}{$\pre \pre \pre$}
      \ac{darrow}{$\pre$}
      \bc{darrow}{$\pre \pre$}
      \bd{darrow}{$ $}
      \cd{darrow}{$\pre$}
    \end{tikzpicture}
  \end{center}
\end{frame}

\begin{frame}
  \begin{center}
    \begin{tikzpicture}
      \nodes{snapped}{transient}{transient}{transient}
      \ab{darrow}{$\tok \pre \pre$}
      \ac{darrow}{$\tok$}
      \bc{darrow}{$\pre$}
      \bd{darrow}{$\pre$}
      \cd{darrow}{$\pre \pre$}
    \end{tikzpicture}
  \end{center}
\end{frame}

\begin{frame}
  \begin{center}
    \begin{tikzpicture}
      \nodes{snapped}{transient}{snapped}{transient}
      \ab{darrow}{$\post \tok \pre$}
      \ac{arrow}{$\post$}
      \bc{darrow}{$\pre \pre$}
      \bd{darrow}{$ $}
      \cd{darrow}{$\tok \pre \pre$}
    \end{tikzpicture}
  \end{center}
\end{frame}

\begin{frame}
  \begin{center}
    \begin{tikzpicture}
      \nodes{snapped}{transient}{snapped}{transient}
      \ab{darrow}{$\post \tok$}
      \ac{arrow}{$\post \post$}
      \bc{darrow}{$\pre$}
      \bd{darrow}{$\pre$}
      \cd{darrow}{$\post \tok \pre$}
    \end{tikzpicture}
  \end{center}
\end{frame}

\begin{frame}
  \begin{center}
    \begin{tikzpicture}
      \nodes{snapped}{snapped}{snapped}{transient}
      \ab{arrow}{$\post \post$}
      \ac{arrow}{$\post \post$}
      \bc{darrow}{$\tok \pre$}
      \bd{darrow}{$\tok \pre$}
      \cd{darrow}{$\post \post \tok$}
    \end{tikzpicture}
  \end{center}
\end{frame}

\begin{frame}
  \begin{center}
    \begin{tikzpicture}
      \nodes{snapped}{snapped}{snapped}{snapped}
      \ab{arrow}{$\post \post \post$}
      \ac{arrow}{$\post$}
      \bc{darrow}{$\post \tok$}
      \bd{darrow}{$\tok$}
      \cd{arrow}{$\post \post \post$}
    \end{tikzpicture}
  \end{center}
\end{frame}

\begin{frame}
  \begin{center}
    \begin{tikzpicture}
      \nodes{snapped}{snapped}{snapped}{snapped}
      \ab{arrow}{$\post \post \post \post$}
      \ac{arrow}{$\ $}
      \bc{arrow}{$\post \post$}
      \bd{arrow}{$\post$}
      \cd{arrow}{$\post \post$}
    \end{tikzpicture}
  \end{center}
\end{frame}
\end{document}
